System: You take in examples of two functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples section. Create examples for the eigvals function.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------

Assistantsystem

You take in examples of two functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples section. Create examples for the eigvals function.
user

Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------
assistant

Here are the examples for the eigvals function:

    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True

    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.848035476

-------------------------------------------------------------------------------------------------


System: You take in examples of two functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples section. Provide only examples for the eigvals function.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------

Assistantsystem

You take in examples of two functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples section. Provide only examples for the eigvals function.
user

Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------
assistant

Here are some examples for the eigvals function:

    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye(2))
    True
    >>> a = np.array([[1, 2], [3, 4]])
    >>> w = LA.eigvals(a)
    >>> w
    array([ 5.  ,  1.  ])
    >>> np.allclose(np.dot(a, np.linalg.inv(w[:, np.newaxis]), np.eye

-------------------------------------------------------------------------------------------------

system

You take in examples of two functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples for the cholesky function. Provide only examples for the cholesky function. 
user

Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: cholesky
Function Body: def cholesky(a, /, *, upper=False):

    

    gufunc = _umath_linalg.cholesky_up if upper else _umath_linalg.cholesky_lo

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_nonposdef, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, signature=signature)

    return wrap(r.astype(result_t, copy=False))

Docstrings: Cholesky decomposition.

    Return the lower or upper Cholesky decomposition, ``L * L.H`` or
    ``U.H * U``, of the square matrix ``a``, where ``L`` is lower-triangular,
    ``U`` is upper-triangular, and ``.H`` is the conjugate transpose operator
    (which is the ordinary transpose if ``a`` is real-valued). ``a`` must be
    Hermitian (symmetric if real-valued) and positive-definite. No checking is
    performed to verify whether ``a`` is Hermitian or not. In addition, only
    the lower or upper-triangular and diagonal elements of ``a`` are used.
    Only ``L`` or ``U`` is actually returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        Hermitian (symmetric if all elements are real), positive-definite
        input matrix.
    upper : bool
        If ``True``, the result must be the upper-triangular Cholesky factor.
        If ``False``, the result must be the lower-triangular Cholesky factor.
        Default: ``False``.

    Returns
    -------
    L : (..., M, M) array_like
        Lower or upper-triangular Cholesky factor of `a`. Returns a matrix
        object if `a` is a matrix object.

    Raises
    ------
    LinAlgError
       If the decomposition fails, for example, if `a` is not
       positive-definite.

    See Also
    --------
    scipy.linalg.cholesky : Similar function in SciPy.
    scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian
                                   positive-definite matrix.
    scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in
                              `scipy.linalg.cho_solve`.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The Cholesky decomposition is often used as a fast way of solving

    .. math:: A \mathbf{x} = \mathbf{b}

    (when `A` is both Hermitian/symmetric and positive-definite).

    First, we solve for :math:`\mathbf{y}` in

    .. math:: L \mathbf{y} = \mathbf{b},

    and then for :math:`\mathbf{x}` in

    .. math:: L^{H} \mathbf{x} = \mathbf{y}.
Examples: ------
assistant

Here are examples for the cholesky function. Please note that these are not the only examples.

    >>> from numpy import linalg as LA
    >>> A = np.array([[1, 0], [0, 0.8]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.31622777]])

    >>> A = np.array([[1, 0], [0, 4]])
    >>> LA.cholesky(A)
    LinAlgError: input matrix is not positive-definite

    >>> A = np.array([[1, 0], [0, 0.6]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.8660254]])


    >>> A = np.array([[1, 0], [0, 0.8]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.81649658]])

    >>> A = np.array([[1, 0], [0, 2]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  1.41421356]])

    >>> A = np.array([[1, 0], [0, 2]])
    >>> LA.cholesky(A)
    LinAlgError: input matrix is not positive-definite

    >>> A = np.array([[1, 0], [0, 0.6]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.81649658]])

    >>> A = np.array([[1, 0], [0, 0.8]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.81649658]])

    >>> A = np.array([[1, 0], [0, 0.6]])
    >>> LA.cholesky(A)
    array([[ 1.        ,  0.        ],
           [ 0.        ,  0.

-------------------------------------------------------------------------------------------------System: You take in an example function with sections Function, Function Body, Docstrings, and Examples. You are given a second function, function body, and docstring. You are to fill in the examples for the cholesky function. Provide only examples for the cholesky function. 

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: cholesky
Function Body: def cholesky(a, /, *, upper=False):

    

    gufunc = _umath_linalg.cholesky_up if upper else _umath_linalg.cholesky_lo

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_nonposdef, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, signature=signature)

    return wrap(r.astype(result_t, copy=False))

Docstrings: Cholesky decomposition.

    Return the lower or upper Cholesky decomposition, ``L * L.H`` or
    ``U.H * U``, of the square matrix ``a``, where ``L`` is lower-triangular,
    ``U`` is upper-triangular, and ``.H`` is the conjugate transpose operator
    (which is the ordinary transpose if ``a`` is real-valued). ``a`` must be
    Hermitian (symmetric if real-valued) and positive-definite. No checking is
    performed to verify whether ``a`` is Hermitian or not. In addition, only
    the lower or upper-triangular and diagonal elements of ``a`` are used.
    Only ``L`` or ``U`` is actually returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        Hermitian (symmetric if all elements are real), positive-definite
        input matrix.
    upper : bool
        If ``True``, the result must be the upper-triangular Cholesky factor.
        If ``False``, the result must be the lower-triangular Cholesky factor.
        Default: ``False``.

    Returns
    -------
    L : (..., M, M) array_like
        Lower or upper-triangular Cholesky factor of `a`. Returns a matrix
        object if `a` is a matrix object.

    Raises
    ------
    LinAlgError
       If the decomposition fails, for example, if `a` is not
       positive-definite.

    See Also
    --------
    scipy.linalg.cholesky : Similar function in SciPy.
    scipy.linalg.cholesky_banded : Cholesky decompose a banded Hermitian
                                   positive-definite matrix.
    scipy.linalg.cho_factor : Cholesky decomposition of a matrix, to use in
                              `scipy.linalg.cho_solve`.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The Cholesky decomposition is often used as a fast way of solving

    .. math:: A \mathbf{x} = \mathbf{b}

    (when `A` is both Hermitian/symmetric and positive-definite).

    First, we solve for :math:`\mathbf{y}` in

    .. math:: L \mathbf{y} = \mathbf{b},

    and then for :math:`\mathbf{x}` in

    .. math:: L^{H} \mathbf{x} = \mathbf{y}.
Examples: ------

Assistant

Examples: --------

    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `

-------------------------------------------------------------------------------------------------

System: You take in an example function with sections Function, Function Body, Docstrings, and Examples. You are given a second function, function body, and docstring. You are to fill in the examples for the eigvals function. Provide only examples for the eigvals function. 

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------

Assistant

Examples: --------

    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.eigvals(a)
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250105])
    >>> np.linalg.eigvals(np.array([[1, 2], [3, 4]]))
    array([1.618033988749895, 0.381966011250

-------------------------------------------------------------------------------------------------

System: You take in an example function with sections Function, Function Body, Docstrings, and Examples. You are given a second function, function body, and docstring. You are to fill in the examples for the eigvals function. Provide only examples for the eigvals function. Please provide multiple different examples

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: ------

Assistant

Here are 10 examples of the `eigvals` function. Please note that the first five examples are from the original implementation of the function, and the other five are new ones that I have added. 

    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigen

-------------------------------------------------------------------------------------------------

System: You take in an example function with sections Function, Function Body, Docstrings, and Examples. You are given a second function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Please provide multiple different examples

User: Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Here are multiple examples for the det function:

    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [3, 0]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [3, 1]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 1]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [2, 1]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [2, 3]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [2, 3]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [0, 1]])
    >>> LA.det(a)
    2.0
    >>> a = np.array([[1, 2], [3, 1]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [2, 1]])
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    3.0 # may vary
    >>> a = np.array([[1, 2], [3, 1]])


-------------------------------------------------------------------------------------------------

System: You take in an example function with sections Function, Function Body, Docstrings, and Examples. You are given a second function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Please provide 5 different examples. 

User: Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Examples: ---------
    >>> from numpy import linalg as LA
    >>> a = np.random.random((2,2))
    >>> LA.det(a)
    0.13276059543683295
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.array([[1, 1], [1, 1]]) # singular, determinant 0
    >>> LA.det(a)
    0.0
    >>> a = np.arange(3).reshape((1,3))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(3).reshape((2,1))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.random.random((3,3))
    >>> LA.det(a)
    0.0
    >>> a = np.random.random((5,5))
    >>> LA.det(a)
    0.0
    >>> a = np.random.random((2,2))
    >>> LA.det(a)
    0.13276059543683295
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a = np.arange(4).reshape((2,2))
    >>> LA.det(a)
    0.0
    >>> a

-------------------------------------------------------------------------------------------------

System: You take in two example functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Please provide a few different examples. 

User: Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

def det(a): 
    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

# Provided examples for det function
def det(a):

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

# Provided examples for det function
Examples: _______
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for det function
# Provided examples for

-------------------------------------------------------------------------------------------------

System: You take in two example functions with sections Function, Function Body, Docstrings, and Examples. You are given a third function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. 

User: Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

def det(a): # real
    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------ 

    >>> from numpy import linalg as LA
    >>> a = np.arange(4).reshape((2,2)
    >>> a
    array([[0, 1],
           [2, 3]]
    >>> LA.det(a)
    1.0 
    >>> b = np.array([[ 0, 1, 2],
    ...               [-1, 2, 3]])
    >>> b
    array([[-1,  2,  3],
           [ 0,  1,  4]])
    >>> LA.det(b)
    (1+2j) * ((1+2j)/2)**(2*4)
    >>> c = np.array([[ 4, 0],
    ...               [ 0, 1]])
    >>> c
    array([[ 4,  0],
           [  0,  1]])
    >>> LA.det(c)
    0.0
    >>> d = np.array([[ 4, 0],
    ...               [ 0, 1]])
    >>> d
    array([[ 4,  0],
           [  0,  1]])
    >>> LA.det(d)
    0.

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be unit tests. 

User: Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Here are the Examples for the det function:

    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 0]])
    >>> LA.det(a)
    nan
    >>> a = np.array([[1, 2], [0, 0]])
    >>> LA.det(a)
    -1.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3,

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be unit tests. 

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

def det(a):
    # Test 1
    a = np.array([[1, 3], [2, 4]])
    det(a)
    # Expected output: 2

    # Test 2
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 3
    a = np.array([[1, 2], [2, 1]])
    det(a)
    # Expected output: 0

    # Test 4
    a = np.array([[1, 2], [2, 1]])
    det(a)
    # Expected output: 0

    # Test 5
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 6
    a = np.array([[1, 2], [7, 8]])
    det(a)
    # Expected output: -14

    # Test 7
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 8
    a = np.array([[1, 2], [3, 0]])
    det(a)
    # Expected output: 0

    # Test 9
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 10
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 11
    a = np.array([[1, 2], [2, 0]])
    det(a)
    # Expected output: 0

    # Test 12
    a = np.array([[1, 2], [3, 1]])
    det(a)
    # Expected output: 0

    # Test 13
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 14
    a = np.array([[1, 2], [3, 4]])
    det(a)
    # Expected output: -2

    # Test 15
    a = np.array([[1, 2],

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be usable as unit tests. 

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Here are the examples for the det function:

    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 0]])
    >>> LA.det(a)
    0.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2],

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be usable as unit tests. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Here are the examples for the det function:

    >>> from numpy import linalg as LA
    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2], [3, 4]])
    >>> LA.det(a)
    -2.0

    >>> a = np.array([[1, 2],

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be usable as unit tests. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: norm
Function Body: def norm(x, ord=None, axis=None, keepdims=False):

    

    x = asarray(x)



    if not issubclass(x.dtype.type, (inexact, object_)):

        x = x.astype(float)



    # Immediately handle some default, simple, fast, and common cases.

    if axis is None:

        ndim = x.ndim

        if (

            (ord is None) or

            (ord in ('f', 'fro') and ndim == 2) or

            (ord == 2 and ndim == 1)

        ):

            x = x.ravel(order='K')

            if isComplexType(x.dtype.type):

                x_real = x.real

                x_imag = x.imag

                sqnorm = x_real.dot(x_real) + x_imag.dot(x_imag)

            else:

                sqnorm = x.dot(x)

            ret = sqrt(sqnorm)

            if keepdims:

                ret = ret.reshape(ndim*[1])

            return ret



    # Normalize the `axis` argument to a tuple.

    nd = x.ndim

    if axis is None:

        axis = tuple(range(nd))

    elif not isinstance(axis, tuple):

        try:

            axis = int(axis)

        except Exception as e:

            raise TypeError(

                "'axis' must be None, an integer or a tuple of integers"

            ) from e

        axis = (axis,)



    if len(axis) == 1:

Docstrings: Matrix or vector norm.

    This function is able to return one of eight different matrix norms,
    or one of an infinite number of vector norms (described below), depending
    on the value of the ``ord`` parameter.

    Parameters
    ----------
    x : array_like
        Input array.  If `axis` is None, `x` must be 1-D or 2-D, unless `ord`
        is None. If both `axis` and `ord` are None, the 2-norm of
        ``x.ravel`` will be returned.
    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
        Order of the norm (see table under ``Notes``). inf means numpy's
        `inf` object. The default is None.
    axis : {None, int, 2-tuple of ints}, optional.
        If `axis` is an integer, it specifies the axis of `x` along which to
        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
        axes that hold 2-D matrices, and the matrix norms of these matrices
        are computed.  If `axis` is None then either a vector norm (when `x`
        is 1-D) or a matrix norm (when `x` is 2-D) is returned. The default
        is None.

        .. versionadded:: 1.8.0

    keepdims : bool, optional
        If this is set to True, the axes which are normed over are left in the
        result as dimensions with size one.  With this option the result will
        broadcast correctly against the original `x`.

        .. versionadded:: 1.10.0

    Returns
    -------
    n : float or ndarray
        Norm of the matrix or vector(s).

    See Also
    --------
    scipy.linalg.norm : Similar function in SciPy.

    Notes
    -----
    For values of ``ord < 1``, the result is, strictly speaking, not a
    mathematical 'norm', but it may still be useful for various numerical
    purposes.

    The following norms can be calculated:

    =====  ============================  ==========================
    ord    norm for matrices             norm for vectors
    =====  ============================  ==========================
    None   Frobenius norm                2-norm
    'fro'  Frobenius norm                --
    'nuc'  nuclear norm                  --
    inf    max(sum(abs(x), axis=1))      max(abs(x))
    -inf   min(sum(abs(x), axis=1))      min(abs(x))
    0      --                            sum(x != 0)
    1      max(sum(abs(x), axis=0))      as below
    -1     min(sum(abs(x), axis=0))      as below
    2      2-norm (largest sing. value)  as below
    -2     smallest singular value       as below
    other  --                            sum(abs(x)**ord)**(1./ord)
    =====  ============================  ==========================

    The Frobenius norm is given by [1]_:

    :math:`||A||_F = [\sum_{i,j} abs(a_{i,j})^2]^{1/2}`

    The nuclear norm is the sum of the singular values.

    Both the Frobenius and nuclear norm orders are only defined for
    matrices and raise a ValueError when ``x.ndim != 2``.

    References
    ----------
    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
Examples: --------
    >>> from numpy import linalg as LA
    >>> a = np.arange(9) - 4
    >>> a
    array([-4, -3, -2, ...,  2,  3,  4])
    >>> b = a.reshape((3, 3))
    >>> b
    array([[-4, -3, -2],
           [-1,  0,  1],
           [ 2,  3,  4]])

    >>> LA.norm(a)
    7.745966692414834
    >>> LA.norm(b)
    7.745966692414834
    >>> LA.norm(b, 'fro')
    7.745966692414834
    >>> LA.norm(a, np.inf)
    4.0
    >>> LA.norm(b, np.inf)
    9.0
    >>> LA.norm(a, -np.inf)
    0.0
    >>> LA.norm(b, -np.inf)
    2.0

    >>> LA.norm(a, 1)
    20.0
    >>> LA.norm(b, 1)
    7.0
    >>> LA.norm(a, -1)
    -4.6566128774142013e-010
    >>> LA.norm(b, -1)
    6.0
    >>> LA.norm(a, 2)
    7.745966692414834
    >>> LA.norm(b, 2)
    7.3484692283495345

    >>> LA.norm(a, -2)
    0.0
    >>> LA.norm(b, -2)
    1.8570331885190563e-016 # may vary
    >>> LA.norm(a, 3)
    5.8480354764257312 # may vary
    >>> LA.norm(a, -3)
    0.0

    Using the `axis` argument to compute vector norms:

    >>> c = np.array([[ 1, 2, 3],
    ...               [-1, 1, 4]])
    >>> LA.norm(c, axis=0)
    array([ 1.41421356,  2.23606798,  5.        ])
    >>> LA.norm(c, axis=1)
    array([ 3.74165739,  4.24264069])
    >>> LA.norm(c, ord=1, axis=1)
    array([ 6.,  6.])

    Using the `axis` argument to compute matrix norms:

    >>> m = np.arange(8).reshape(2,2,2)
    >>> LA.norm(m, axis=(1,2))
    array([  3.74165739,  11.22497216])
    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
    (3.7416573867739413, 11.224972160321824)
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Examples: 0
Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Examples: 1
Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Examples: 2
Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Examples: 2
Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Examples: 2
Solve the system of equations:
    ``x

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. These Examples should be usable as unit tests. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

def det(a): # Example 1
    assert det(np.array([[1, 2]])) == 0
    assert det(np.array([[1]])) == 1
    assert det(np.array([[1, 2],
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    det(np.array([[1, 2],
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    assert det(np.array([[1, 2,
                     [3, 4]])) == -2
    if not np.can_cast('int', result_t):
        assert det(np.array([[0]])) == 0
    assert det(np.array([[np.inf],
                     [np.inf]])) == np.inf
    assert det(np.array([[np.inf,
                     [np.inf]])) == 0
    #assert det(np.array([[0,
                     [0]]))
    #assert det(np.array([[0]])) == 0
    return 1.0 if np.isfinite(r) else np.nan if np.iscomplex(t) else np.inf

# Example 2
assert det(np.array([[1, 2, 3],
                     [4, 5, 6],
                     [7, 8, 9]])) == 0
# Example 3
assert det(np.array([[1, 2, 3],
                     [4, 5, 6],
                     [7, 8, 9]])) == 0
# Example 4
assert det(np.array([[1, 2, 3],
                    

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

def det(a): # line 6
    return a
    # Examples: -------- # >>> a = np.array([[1, 2], [3, 4]])
    # >>> det(a)
    # array([ -2.])
    # >>> a = np.array([[1, 2], [3, 0]])
    # >>> det(a)
    # array([ 0.])
    # >>> a = np.array([[1, 2], [3, 4], [5, 6]])
    # >>> det(a)
    # array([  0.])
    # >>> a = np.array([[1, 2], [3, 4], [5, 6]])
    # >>> det(a)
    # array([  0.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(int)
    # >>> det(a)
    # array([ 0.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(int)
    # >>> det(a)
    # array([ 0.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(int)
    # >>> det(a)
    # array([ 0.])
    # >>> a = np.array([[1, 2], [3, 4]].astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3, 4]]).astype(float)
    # >>> det(a)
    # array([ 3.])
    # >>> a = np.array([[1, 2], [3,

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Examples: -----------
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [0, 1]])
    >>> np.linalg.det(a)
    1.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: solve
Function Body: def solve(a, b):

    

    a, _ = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    b, wrap = _makearray(b)

    t, result_t = _commonType(a, b)



    # We use the b = (..., M,) logic, only if the number of extra dimensions

    # match exactly

    if b.ndim == 1:

        gufunc = _umath_linalg.solve1

    else:

        gufunc = _umath_linalg.solve



    signature = 'DD->D' if isComplexType(t) else 'dd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        r = gufunc(a, b, signature=signature)



    return wrap(r.astype(result_t, copy=False))

Docstrings: Solve a linear matrix equation, or system of linear scalar equations.

    Computes the "exact" solution, `x`, of the well-determined, i.e., full
    rank, linear matrix equation `ax = b`.

    Parameters
    ----------
    a : (..., M, M) array_like
        Coefficient matrix.
    b : {(M,), (..., M, K)}, array_like
        Ordinate or "dependent variable" values.

    Returns
    -------
    x : {(..., M,), (..., M, K)} ndarray
        Solution to the system a x = b.  Returned shape is (..., M) if b is
        shape (M,) and (..., M, K) if b is (..., M, K), where the "..." part is
        broadcasted between a and b.

    Raises
    ------
    LinAlgError
        If `a` is singular or not square.

    See Also
    --------
    scipy.linalg.solve : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The solutions are computed using LAPACK routine ``_gesv``.

    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
    columns) must be linearly independent; if either is not true, use
    `lstsq` for the least-squares best "solution" of the
    system/equation.

    .. versionchanged:: 2.0

       The b array is only treated as a shape (M,) column vector if it is
       exactly 1-dimensional. In all other instances it is treated as a stack
       of (M, K) matrices. Previously b would be treated as a stack of (M,)
       vectors if b.ndim was equal to a.ndim - 1.

    References
    ----------
    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
           FL, Academic Press, Inc., 1980, pg. 22.
Examples: --------
    Solve the system of equations:
    ``x0 + 2 * x1 = 1`` and
    ``3 * x0 + 5 * x1 = 2``:

    >>> a = np.array([[1, 2], [3, 5]])
    >>> b = np.array([1, 2])
    >>> x = np.linalg.solve(a, b)
    >>> x
    array([-1.,  1.])

    Check that the solution is correct:

    >>> np.allclose(np.dot(a, x), b)
    True
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Examples: -----------
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0
    >>> a = np.array([[1, 2], [4, 5]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    0.0
    >>> a

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the det function. Provide only examples for the det function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: 
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: ------

Assistant

Here are 6 examples for the det function. Do not start an example without finishing it. Do not provide repeat examples. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example without finishing it. Do not start an example

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the trace function. Provide only examples for the trace function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: --------
    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0 # may vary

    Computing determinants for a stack of matrices:

    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
    >>> a.shape
    (3, 2, 2)
    >>> np.linalg.det(a)
    array([-2., -3., -8.])
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: ------

Assistant

The trace function.

    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.trace(a)
    5.0 # may vary

    Computing traces for a stack of matrices:

    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
    >>> a.shape
    (3, 2, 2)
    >>> np.linalg.trace(a)
    array([ 1.,  1.,  0.])

    If the array is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    The trace function works with a 3D array with shape (I, J, K, ..., L, M, N), where
    the last two dimensions have the same axes labels. For example, if the shape
    is (I, J, K, ..., L, M, N), then an output array has shape

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the trace function. Provide only examples for the trace function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: det
Function Body: def det(a):

    

    a = asarray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)

    signature = 'D->D' if isComplexType(t) else 'd->d'

    r = _umath_linalg.det(a, signature=signature)

    r = r.astype(result_t, copy=False)

    return r

Docstrings: Compute the determinant of an array.

    Parameters
    ----------
    a : (..., M, M) array_like
        Input array to compute determinants for.

    Returns
    -------
    det : (...) array_like
        Determinant of `a`.

    See Also
    --------
    slogdet : Another way to represent the determinant, more suitable
      for large matrices where underflow/overflow may occur.
    scipy.linalg.det : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    The determinant is computed via LU factorization using the LAPACK
    routine ``z/dgetrf``.
Examples: --------
    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:

    >>> a = np.array([[1, 2], [3, 4]])
    >>> np.linalg.det(a)
    -2.0 # may vary

    Computing determinants for a stack of matrices:

    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
    >>> a.shape
    (3, 2, 2)
    >>> np.linalg.det(a)
    array([-2., -3., -8.])
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: ------

Assistant

The trace function for a 2-D array:

    >>> np.linalg.det(np.array([[1, 2], [3, 4]]))
    -2.0

The trace function for a 3-D array:

    >>> A = np.array([[[1, 2], [3, 4]], [[1, 2], [3, 4]], [[1, 2], [3, 4]]])
    >>> np.linalg.det(A)
    array([-2., -3., -8.])

The trace function for a 4-D array:

    >>> A = np.array([[[[1, 2], [3, 4]], [[1, 2], [3, 4]], [[1, 2], [3, 4]], [[1, 2], [3, 4]]])
    >>> np.linalg.det(A)
    array([-2., -3., -8.])

The trace function for a 5-D array:

    >>> A = np.array([[[[[1, 2], [3, 4]], [[1, 2], [3, 4]], [[1, 2], [3, 4]]]], [[[[1, 

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to fill in the examples for the trace function. Provide only examples for the trace function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: ------

Assistant

Examples:  ######

    >>> from numpy.linalg import trace
    >>> a = np.array([[1, 2], [3, 4]])
    >>> trace(a)
    5
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=complex)
    >>> trace(a)
    -1.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)
    >>> trace(a)
    5.0
    >>> a = np.array([[1, 2], [3, 4]], dtype=float)


-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. You are to produce examples for the trace function. Provide only examples for the trace function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: ------

Assistant

Examples: ---------
    >>> import numpy as np
    >>> from numpy import trace
    >>> a = np.array([[1, 2], [3, 4]])
    >>> trace(a)
    3
    >>> trace([[[1, 2], [3, 4]]])
    3
    >>> from numpy import array
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> trace(array([[1, 2], [3, 4]]))
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2], [3, 4]])
    >>> trace(x + 100j)
    3
    >>> x = np.array([[1, 2],

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. Please write examples for the trace function. Provide only examples for the trace function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: trace
Function Body: def trace(x, /, *, offset=0, dtype=None):

    

    return _core_trace(x, offset, axis1=-2, axis2=-1, dtype=dtype)

Docstrings: Returns the sum along the specified diagonals of a matrix
    (or a stack of matrices) ``x``.

    This function is Array API compatible, contrary to
    :py:func:`numpy.trace`.

    Parameters
    ----------
    x : (...,M,N) array_like
        Input array having shape (..., M, N) and whose innermost two
        dimensions form MxN matrices.
    offset : int, optional
        Offset specifying the off-diagonal relative to the main diagonal,
        where::

            * offset = 0: the main diagonal.
            * offset > 0: off-diagonal above the main diagonal.
            * offset < 0: off-diagonal below the main diagonal.

    dtype : dtype, optional
        Data type of the returned array.

    Returns
    -------
    out : ndarray
        An array containing the traces and whose shape is determined by
        removing the last two dimensions and storing the traces in the last
        array dimension. For example, if x has rank k and shape:
        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:
        (I, J, K, ..., L) where::

            out[i, j, k, ..., l] = trace(a[i, j, k, ..., l, :, :])

        The returned array must have a data type as described by the dtype
        parameter above.

    See Also
    --------
    numpy.trace
Examples: ------

Assistant

Examples: --------
    >>> from numpy import trace
    >>> trace([[1, 2], [3, 4])
    5
    >>> trace([[[1, 2], [3, 4], [5, 6]], offset=1)
    5
    >>> trace([[1, 2], [3, 4]], offset=-1)
    3
    >>> trace([[1, 2], [3, 4]], offset=-2)
    1
    >>> trace([[1, 2], [3, 4]], offset=2)
    1
    >>> trace([[1, 2], [3, 4]], offset=-2)
    1
    >>> trace([[1, 2], [3, 4]], offset=-1)
    5
    >>> trace([[1, 2], [3, 4]], offset=1)
    0
    >>> trace([[1, 2], [3, 4]], offset=0)
    5
    >>> trace([[1, 2], [3, 4]], offset=-1)
    5
    >>> trace([[1, 2], [3, 4]], offset=-2)
    3
    >>> trace([[1, 2], [3, 4]], offset=-2)
    1
    >>> trace([[1, 2], [3, 4]], offset=-1)
    5
    >>> trace([[1, 2], [3, 4]], offset=0)
    5
    >>> trace([[1, 2], [3, 4]], offset=1)
    0
    >>> trace([[1, 2], [3, 4]], offset=0)
    5
    >>> trace([[1, 2], [3, 4]], offset=-1)
    5
    >>> trace([[1, 2], [3, 4]], offset=-2)
    1
    >>> trace([[1, 2], [3, 4]], offset=-1)
    5
    >>> trace([[1, 2], [3, 4]], offset=1)
    0
    >>> trace([[1, 2], [3, 4]], offset=0)
    5
    >>> trace([[1, 2], [3, 4]],

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. Please write examples for the cross function. Provide only examples for the cross function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: cross
Function Body: def cross(x1, x2, /, *, axis=-1):

    

    if x1.shape[axis] != 3 or x2.shape[axis] != 3:

        raise ValueError(

            "Both input arrays must be (arrays of) 3-dimensional vectors, "

            f"but they are {x1.shape[axis]} and {x2.shape[axis]} "

            "dimensional instead."

        )



    return _core_cross(x1, x2, axis=axis)

Docstrings: Returns the cross product of 3-element vectors.

    If ``x1`` and/or ``x2`` are multi-dimensional arrays, then
    the cross-product of each pair of corresponding 3-element vectors
    is independently computed.

    This function is Array API compatible, contrary to
    :func:`numpy.cross`.

    Parameters
    ----------
    x1 : array_like
        The first input array.
    x2 : array_like
        The second input array. Must be compatible with ``x1`` for all
        non-compute axes. The size of the axis over which to compute
        the cross-product must be the same size as the respective axis
        in ``x1``.
    axis : int, optional
        The axis (dimension) of ``x1`` and ``x2`` containing the vectors for
        which to compute the cross-product. Default: ``-1``.

    Returns
    -------
    out : ndarray
        An array containing the cross products.

    See Also
    --------
    numpy.cross
Examples: ------

Assistant

Examples: --------

    >>> import numpy as np
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]
    >>> np.cross(a, a)
    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> np.cross(a, a)
    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> np.cross(a, a)
    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> np.cross(a, a)
    array([[ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> a = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
    >>> np.cross(a, a)
    array([[ 0.,  0.,  0.],
           [ 0.,

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. Please write examples for the cross function. Provide only examples for the cross function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: cross
Function Body: def cross(x1, x2, /, *, axis=-1):

    

    if x1.shape[axis] != 3 or x2.shape[axis] != 3:

        raise ValueError(

            "Both input arrays must be (arrays of) 3-dimensional vectors, "

            f"but they are {x1.shape[axis]} and {x2.shape[axis]} "

            "dimensional instead."

        )



    return _core_cross(x1, x2, axis=axis)

Docstrings: Returns the cross product of 3-element vectors.

    If ``x1`` and/or ``x2`` are multi-dimensional arrays, then
    the cross-product of each pair of corresponding 3-element vectors
    is independently computed.

    This function is Array API compatible, contrary to
    :func:`numpy.cross`.

    Parameters
    ----------
    x1 : array_like
        The first input array.
    x2 : array_like
        The second input array. Must be compatible with ``x1`` for all
        non-compute axes. The size of the axis over which to compute
        the cross-product must be the same size as the respective axis
        in ``x1``.
    axis : int, optional
        The axis (dimension) of ``x1`` and ``x2`` containing the vectors for
        which to compute the cross-product. Default: ``-1``.

    Returns
    -------
    out : ndarray
        An array containing the cross products.

    See Also
    --------
    numpy.cross
Examples: ------

Assistant

Examples: 1
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 2
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 3
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 4
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 5
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 6
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 7
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 8
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 9
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 10
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 11
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 0, -3,  0])

    Examples: 12
    >>> cross(np.array([1, 2, 3]), np.array([4, 5,

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. Please write examples for the cross function. Provide only examples for the cross function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: minimum_fill_value
Function Body: def minimum_fill_value(obj):

    

    return _extremum_fill_value(obj, min_filler, "minimum")

Docstrings: Return the maximum value that can be represented by the dtype of an object.

    This function is useful for calculating a fill value suitable for
    taking the minimum of an array with a given dtype.

    Parameters
    ----------
    obj : ndarray, dtype or scalar
        An object that can be queried for it's numeric type.

    Returns
    -------
    val : scalar
        The maximum representable value.

    Raises
    ------
    TypeError
        If `obj` isn't a suitable numeric type.

    See Also
    --------
    maximum_fill_value : The inverse function.
    set_fill_value : Set the filling value of a masked array.
    MaskedArray.fill_value : Return current fill value.
Examples: --------
    >>> import numpy.ma as ma
    >>> a = np.int8()
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.int32()
    >>> ma.minimum_fill_value(a)
    2147483647

    An array of numeric data can also be passed.

    >>> a = np.array([1, 2, 3], dtype=np.int8)
    >>> ma.minimum_fill_value(a)
    127
    >>> a = np.array([1, 2, 3], dtype=np.float32)
    >>> ma.minimum_fill_value(a)
    inf
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: cross
Function Body: def cross(x1, x2, /, *, axis=-1):

    

    if x1.shape[axis] != 3 or x2.shape[axis] != 3:

        raise ValueError(

            "Both input arrays must be (arrays of) 3-dimensional vectors, "

            f"but they are {x1.shape[axis]} and {x2.shape[axis]} "

            "dimensional instead."

        )



    return _core_cross(x1, x2, axis=axis)

Docstrings: Returns the cross product of 3-element vectors.

    If ``x1`` and/or ``x2`` are multi-dimensional arrays, then
    the cross-product of each pair of corresponding 3-element vectors
    is independently computed.

    This function is Array API compatible, contrary to
    :func:`numpy.cross`.

    Parameters
    ----------
    x1 : array_like
        The first input array.
    x2 : array_like
        The second input array. Must be compatible with ``x1`` for all
        non-compute axes. The size of the axis over which to compute
        the cross-product must be the same size as the respective axis
        in ``x1``.
    axis : int, optional
        The axis (dimension) of ``x1`` and ``x2`` containing the vectors for
        which to compute the cross-product. Default: ``-1``.

    Returns
    -------
    out : ndarray
        An array containing the cross products.

    See Also
    --------
    numpy.cross
Examples: ------

Assistant

Examples: --------

    >>> import numpy as np
    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6]), np.array([[7, 8, 9], [10, 11, 12]))
    array([[-3,  6, -3],
           [ 3, -6,  3]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6]), np.array([[7, 8, 9], [10, 11, 12]))
    array([[-3,  6, -3],
           [ 3, -6,  3]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], np.array([[7, 8, 9], [10, 11, 12], [13, 14, 15]))
    array([[-6,  0,  0],
           [ 0,  0,  0],
           [ 0,  0,  0]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]), np.array([[7, 8, 9], [10, 11, 12], [13, 14, 15]))
    array([[-0,  0,  0],
           [ 0,  0,  0],
           [ 0,  0,  0]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6]), np.array([[7, 8, 9], [10, 11, 12]))
    array([[-3,  6, -3],
           [ 3, -6,  3]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5, 6]), np.array([[7, 8, 9], [10, 11, 12]))
    array([[-3,  6, -3],
           [ 3, -6,  3]])

    >>> np.cross(np.array([[1, 2, 3], [4, 5

-------------------------------------------------------------------------------------------------

System: You take in three example functions with sections Function, Function Body, Docstrings, and Examples. You are given a fourth function, function body, and docstring. Please write examples for the cross function. Provide only examples for the cross function. Do not provide repeat examples. Do not start an example without finishing it.

User: Function: inv
Function Body: def inv(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->d'

    with errstate(call=_raise_linalgerror_singular, invalid='call',

                  over='ignore', divide='ignore', under='ignore'):

        ainv = _umath_linalg.inv(a, signature=signature)

    return wrap(ainv.astype(result_t, copy=False))

Docstrings: Compute the inverse of a matrix.

    Given a square matrix `a`, return the matrix `ainv` satisfying
    ``a @ ainv = ainv @ a = eye(a.shape[0])``.

    Parameters
    ----------
    a : (..., M, M) array_like
        Matrix to be inverted.

    Returns
    -------
    ainv : (..., M, M) ndarray or matrix
        Inverse of the matrix `a`.

    Raises
    ------
    LinAlgError
        If `a` is not square or inversion fails.

    See Also
    --------
    scipy.linalg.inv : Similar function in SciPy.
    numpy.linalg.cond : Compute the condition number of a matrix.
    numpy.linalg.svd : Compute the singular value decomposition of a matrix.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    If `a` is detected to be singular, a `LinAlgError` is raised. If `a` is
    ill-conditioned, a `LinAlgError` may or may not be raised, and results may
    be inaccurate due to floating-point errors.

    References
    ----------
    .. [1] Wikipedia, "Condition number",
           https://en.wikipedia.org/wiki/Condition_number
Examples: --------
    >>> from numpy.linalg import inv
    >>> a = np.array([[1., 2.], [3., 4.]])
    >>> ainv = inv(a)
    >>> np.allclose(a @ ainv, np.eye(2))
    True
    >>> np.allclose(ainv @ a, np.eye(2))
    True

    If a is a matrix object, then the return value is a matrix as well:

    >>> ainv = inv(np.matrix(a))
    >>> ainv
    matrix([[-2. ,  1. ],
            [ 1.5, -0.5]])

    Inverses of several matrices can be computed at once:

    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
    >>> inv(a)
    array([[[-2.  ,  1.  ],
            [ 1.5 , -0.5 ]],
           [[-1.25,  0.75],
            [ 0.75, -0.25]]])

    If a matrix is close to singular, the computed inverse may not satisfy
    ``a @ ainv = ainv @ a = eye(a.shape[0])`` even if a `LinAlgError`
    is not raised:

    >>> a = np.array([[2,4,6],[2,0,2],[6,8,14]])
    >>> inv(a)  # No errors raised
    array([[-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [-1.12589991e+15, -5.62949953e+14,  5.62949953e+14],
       [ 1.12589991e+15,  5.62949953e+14, -5.62949953e+14]])
    >>> a @ inv(a)
    array([[ 0.   , -0.5  ,  0.   ],  # may vary
           [-0.5  ,  0.625,  0.25 ],
           [ 0.   ,  0.   ,  1.   ]])

    To detect ill-conditioned matrices, you can use `numpy.linalg.cond` to
    compute its *condition number* [1]_. The larger the condition number, the
    more ill-conditioned the matrix is. As a rule of thumb, if the condition
    number ``cond(a) = 10**k``, then you may lose up to ``k`` digits of
    accuracy on top of what would be lost to the numerical method due to loss
    of precision from arithmetic methods.

    >>> from numpy.linalg import cond
    >>> cond(a)
    np.float64(8.659885634118668e+17)  # may vary

    It is also possible to detect ill-conditioning by inspecting the matrix's
    singular values directly. The ratio between the largest and the smallest
    singular value is the condition number:

    >>> from numpy.linalg import svd
    >>> sigma = svd(a, compute_uv=False)  # Do not compute singular vectors
    >>> sigma.max()/sigma.min()
    8.659885634118668e+17  # may vary
Function: eigvals
Function Body: def eigvals(a):

    

    a, wrap = _makearray(a)

    _assert_stacked_2d(a)

    _assert_stacked_square(a)

    _assert_finite(a)

    t, result_t = _commonType(a)



    signature = 'D->D' if isComplexType(t) else 'd->D'

    with errstate(call=_raise_linalgerror_eigenvalues_nonconvergence,

                  invalid='call', over='ignore', divide='ignore',

                  under='ignore'):

        w = _umath_linalg.eigvals(a, signature=signature)



    if not isComplexType(t):

        if all(w.imag == 0):

            w = w.real

            result_t = _realType(result_t)

        else:

            result_t = _complexType(result_t)



    return w.astype(result_t, copy=False)

Docstrings: Compute the eigenvalues of a general matrix.

    Main difference between `eigvals` and `eig`: the eigenvectors aren't
    returned.

    Parameters
    ----------
    a : (..., M, M) array_like
        A complex- or real-valued matrix whose eigenvalues will be computed.

    Returns
    -------
    w : (..., M,) ndarray
        The eigenvalues, each repeated according to its multiplicity.
        They are not necessarily ordered, nor are they necessarily
        real for real matrices.

    Raises
    ------
    LinAlgError
        If the eigenvalue computation does not converge.

    See Also
    --------
    eig : eigenvalues and right eigenvectors of general arrays
    eigvalsh : eigenvalues of real symmetric or complex Hermitian
               (conjugate symmetric) arrays.
    eigh : eigenvalues and eigenvectors of real symmetric or complex
           Hermitian (conjugate symmetric) arrays.
    scipy.linalg.eigvals : Similar function in SciPy.

    Notes
    -----

    .. versionadded:: 1.8.0

    Broadcasting rules apply, see the `numpy.linalg` documentation for
    details.

    This is implemented using the ``_geev`` LAPACK routines which compute
    the eigenvalues and eigenvectors of general square arrays.
Examples: --------
    Illustration, using the fact that the eigenvalues of a diagonal matrix
    are its diagonal elements, that multiplying a matrix on the left
    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
    of `Q`), preserves the eigenvalues of the "middle" matrix. In other words,
    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
    ``A``:

    >>> from numpy import linalg as LA
    >>> x = np.random.random()
    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
    (1.0, 1.0, 0.0)

    Now multiply a diagonal matrix by ``Q`` on one side and
    by ``Q.T`` on the other:

    >>> D = np.diag((-1,1))
    >>> LA.eigvals(D)
    array([-1.,  1.])
    >>> A = np.dot(Q, D)
    >>> A = np.dot(A, Q.T)
    >>> LA.eigvals(A)
    array([ 1., -1.]) # random
Function: asarray
Function Body: def asarray(a, dtype=None, order=None):

    

    order = order or 'C'

    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,

Docstrings: Convert the input to a masked array of the given data-type.

    No copy is performed if the input is already an `ndarray`. If `a` is
    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.

    Parameters
    ----------
    a : array_like
        Input data, in any form that can be converted to a masked array. This
        includes lists, lists of tuples, tuples, tuples of tuples, tuples
        of lists, ndarrays and masked arrays.
    dtype : dtype, optional
        By default, the data-type is inferred from the input data.
    order : {'C', 'F'}, optional
        Whether to use row-major ('C') or column-major ('FORTRAN') memory
        representation.  Default is 'C'.

    Returns
    -------
    out : MaskedArray
        Masked array interpretation of `a`.

    See Also
    --------
    asanyarray : Similar to `asarray`, but conserves subclasses.
Examples: --------
    >>> x = np.arange(10.).reshape(2, 5)
    >>> x
    array([[0., 1., 2., 3., 4.],
           [5., 6., 7., 8., 9.]])
    >>> np.ma.asarray(x)
    masked_array(
      data=[[0., 1., 2., 3., 4.],
            [5., 6., 7., 8., 9.]],
      mask=False,
      fill_value=1e+20)
    >>> type(np.ma.asarray(x))
    <class 'numpy.ma.MaskedArray'>
Function: cross
Function Body: def cross(x1, x2, /, *, axis=-1):

    

    if x1.shape[axis] != 3 or x2.shape[axis] != 3:

        raise ValueError(

            "Both input arrays must be (arrays of) 3-dimensional vectors, "

            f"but they are {x1.shape[axis]} and {x2.shape[axis]} "

            "dimensional instead."

        )



    return _core_cross(x1, x2, axis=axis)

Docstrings: Returns the cross product of 3-element vectors.

    If ``x1`` and/or ``x2`` are multi-dimensional arrays, then
    the cross-product of each pair of corresponding 3-element vectors
    is independently computed.

    This function is Array API compatible, contrary to
    :func:`numpy.cross`.

    Parameters
    ----------
    x1 : array_like
        The first input array.
    x2 : array_like
        The second input array. Must be compatible with ``x1`` for all
        non-compute axes. The size of the axis over which to compute
        the cross-product must be the same size as the respective axis
        in ``x1``.
    axis : int, optional
        The axis (dimension) of ``x1`` and ``x2`` containing the vectors for
        which to compute the cross-product. Default: ``-1``.

    Returns
    -------
    out : ndarray
        An array containing the cross products.

    See Also
    --------
    numpy.cross
Examples: ------

Assistant

Here are some examples for the cross function:

    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0]) # cross([1, 2, 3], [4, 5, 6])

    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
    array([ 3, -3,  0])
    >>> cross(np.array([1, 2, 3]), np.array([4, 5, 6]))
   

-------------------------------------------------------------------------------------------------

